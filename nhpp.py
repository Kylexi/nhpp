import numpy as np

"""
Author: Matthew Campbell
Date of creation: 2/21/21
Date last edited: 2/23/21

PURPOSE: This package is (currently) a standalone module for
generating non-homogeneous Poisson processes (nhpp).
Homogeneous Poisson processes are easily generated by specifying
an arrival rate, lambda, then generating samples from 
X ~ exp(1 / lambda). These samples indicate the inter-arrival
times between events, or the delay between events.

	The above case is only true when lambda is a constant.
Generalizing to the case of lambda(t), a time-dependent arrival
rate, is much trickier to implement. Two main approaches exist
to tackle this issue: (1) relate the INTEGRATED rate function
LAMBDA(t) to a homogeneous Poisson process via an inversion function,
or (2), use a "thinning" method which acts as an acceptance-rejection
sampling routine.

	The method get_arrivals employs the former approach. The input
allows the user to specify a piecewise linear approximation to their
true arrival rate function. Returned is a list containing the arrival
times governed by the arrival rate function.

EXAMPLE USAGE:
# Specify the piecewise linear arrival rate via knots.
# Below we specify arrival_rate = 1 at time = 0, arrival_rate = 2 at time = 5,
# arrival_rate = 1 at time = 2.5 (linearity between time = 0 and time = 5), etc.
>>> knots = {0: 1, 5: 2, 12: 0.3, 15: 0.3, 16: 0, 18: 0, 20: 2}

>>> arrs = nhpp.get_arrivals(knots)

# Print out our arrival times.
>>> for arr in arrs:
		print(round(arr, 2))

0
0.08
1.1
1.14
2.35
2.41
2.45
2.91
3.67
4.41
4.65
4.7
6.78
7.13
7.18
8.12
10.15
18.33
19.21
19.53
19.54
"""


def get_arrivals(knots):
	"""
	Generate a sequence from nonhomogeneous Poisson process
	specified by a piecewise linear function determine from
	the knots parameter. The knots should specify the (domain, range)
	pairings of each segment of the piecewise function.

	knots: dictionary where keys and values should all be numeric.
	"""
	a = [0] # Arrival times for nonhomogeneous poisson process
	u = [0] # Arrival times for homogeneous poisson process 
	j = 0   # Counter to see which 'piece' of the integrated rate function we are in.
	s = []  # Holds the slope between each knot
	L = [0] # Holds values for integrated rate function.

	knots = {i: knots[i] for i in sorted(knots.keys())}

	knot_times = list(knots.keys())
	knot_vals = list(knots.values())

	for i in range(1, len(knot_times)):
		L.append(L[-1] + 
			0.5 * (knot_vals[i] + knot_vals[i-1]) * 
			(knot_times[i] - knot_times[i-1])
			)
		s.append((knot_vals[i] - knot_vals[i-1]) / 
			(knot_times[i] - knot_times[i-1]))

	def inv_int_rate_func(u, j):
		res = 0
		if s[j] != 0:
			res = knot_times[j] + 2 * (u - L[j]) / (
				knot_vals[j] + np.sqrt(
					knot_vals[j]**2 + 2 * s[j] * (u - L[j])
					)
				)
		else:
			res = knot_times[j] + (u - L[j]) / knot_vals[j]
		return res

	while True:
		u_next = u[-1] + np.random.exponential(1.0)
		if u_next >= L[-1]:
			break
		while L[j+1] < u_next and j < len(knot_times):
			j += 1
		a_next = inv_int_rate_func(u_next, j)
		a.append(a_next)
		u.append(u_next)
	return a
